<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Assembly on tuket</title>
    <link>https://tuket.github.io/notes/asm/</link>
    <description>Recent content in Assembly on tuket</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://tuket.github.io/notes/asm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ELF64 hello world</title>
      <link>https://tuket.github.io/notes/asm/elf64_hello_world/</link>
      <pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tuket.github.io/notes/asm/elf64_hello_world/</guid>
      <description>I like to understand how things work under the hood. Assembly programming is very close to the metal but, even then, the assembler hides some complexity to make our lives easier. Also the linker does lots of work I don&amp;rsquo;t completely understand.
So I though I would make an executable by hand, where every bit in it is understood. The resulting ELF64 executable is very small (160 bytes) compared with the executables generated by C compilers and even assemblers.</description>
    </item>
    
    <item>
      <title>GDB commands for Assembly</title>
      <link>https://tuket.github.io/notes/asm/gdb_asm/</link>
      <pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tuket.github.io/notes/asm/gdb_asm/</guid>
      <description>Start up:
gdb exe Change the assembler syntax from AT&amp;amp;T to Intel:
set disassembly-flavor intel If you want to make this setting permanent, paste that into ~/gdbinit.
You can verify which assembly syntax is active with:
show disassembly-flavor Enter TUI mode:
Ctrl+X, Ctrl+A Switch to assembly mode:
layout asm Run the program and break in the first like of work (b main and b _start don&amp;rsquo;t work):
starti Execute till next instruction:</description>
    </item>
    
    <item>
      <title>Hello world in Linux</title>
      <link>https://tuket.github.io/notes/asm/hello_world_linux/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tuket.github.io/notes/asm/hello_world_linux/</guid>
      <description>This is a minimal hello world program in Linux. It doesn&amp;rsquo;t need to link any external libraries.
SECTION .text global _start ; &amp;#34;global&amp;#34; means that the symbol can be accessed in other modules. In order to refer to a global symbol from another module, you must use the &amp;#34;extern&amp;#34; keyboard _start: mov eax, 4 ; syscall: write mov ebx, 1 ; stdout mov ecx, msg mov edx, msgLen syscall mov eax, 1 ; syscal: exit mov ebx, 0 ; return code syscall msg: db &amp;#34;hello&amp;#34;,10 msgLen: equ $ - msg ; the $ sign means the current byte address.</description>
    </item>
    
    <item>
      <title>Print the contents of a file in Linux</title>
      <link>https://tuket.github.io/notes/asm/print_file_linux/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://tuket.github.io/notes/asm/print_file_linux/</guid>
      <description>; nasm -f elf64 pf.asm &amp;amp;&amp;amp; ld -nostartfiles pf.o -o pf SECTION .text global _start _start: mov rax, 2 ; syscall: open mov rdi, str_testFile mov rsi, 0 ; flags syscall mov rdi, rax ; the file descriptor mov rsi, buffer mov rdx, 128 mov rax, 0; syscall: read syscall mov rdi, 1 ; stdout mov rsi, buffer mov rdx, rax ; the size returned by read mov rax, 1; syscall: write syscall mov rax, 60 ; syscal: exit mov rdi, 0 ; return code syscall str_testFile: db &amp;#34;test.</description>
    </item>
    
  </channel>
</rss>
